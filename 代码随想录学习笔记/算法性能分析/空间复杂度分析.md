什么是空间复杂度呢？

是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)。

空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。

关注空间复杂度有两个常见的相关问题

1. 空间复杂度是考虑程序（可执行文件）的大小么？

很多同学都会混淆程序运行时内存大小和程序本身的大小。这里强调一下**空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。**

2. 空间复杂度是准确算出程序运行时所占用的内存么？

不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。

所以空间复杂度是预先大体评估程序内存使用的大小。

说到空间复杂度，我想同学们在OJ（online judge）上应该遇到过这种错误，就是超出内存限制，一般OJ对程序运行时的所消耗的内存都有一个限制。

为了避免内存超出限制，这也需要我们对算法占用多大的内存有一个大体的预估。

同样在工程实践中，计算机的内存空间也不是无限的，需要工程师对软件运行时所使用的内存有一个大体评估，这都需要用到算法空间复杂度的分析。

来看一下例子，什么时候的空间复杂度是$O(1)$呢，C++代码如下：
```
int j = 0;
for (int i = 0; i < n; i++) {
    j++;
}
```
第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。

什么时候的空间复杂度是O(n)？

当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码
```
int* a = new int(n);
for (int i = 0; i < n; i++) {
    a[i] = i;
}
```
我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。

其他的 O(n^2)， O(n^3) 我想大家应该都可以以此例举出来了，**那么思考一下 什么时候空间复杂度是 O(logn)呢？**
```
//O(n^2)
int **a = new int*[n];
for (int i = 0; i < n; i++) {
    a[i] = new int[n];
}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        a[i][j] = i*j;
    }
}
```

```
//O(n^3)
int ***a = new int**[n];
for (int i = 0; i < n; i++) {
    a[i] = new int*[n];
    for (int j = 0; j < n; j++) {
        a[i][j] = new int[n];
    }
}

for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k++) {
            a[i][j][k] = i*j*k;
        }
    }
}
```



空间复杂度是logn的情况确实有些特殊，其实是在**递归的时候，会出现空间复杂度为logn的情况**。
空间复杂度为O(log n)通常出现在分治算法、二叉树等数据结构的实现中。在这些算法和数据结构中，问题通常被分解成规模较小的子问题，每个子问题的规模是原问题规模的一部分。例如，在二叉搜索树中，每个节点最多有两个子节点，因此树的高度是O(log n)，因此存储它所需的空间也是O(log n)。

在分治算法中，问题通常被分成两个或更多的子问题，每个子问题的规模通常是原问题规模的一半。在这种情况下，递归树的高度也是O(log n)，因此存储所有递归调用所需的空间也是O(log n)。例如，在归并排序算法中，每个递归层级的数组大小都是原始输入大小的一半，因此递归树的高度是O(log n)，因此该算法的空间复杂度也是O(log n)。

需要注意的是，这里的空间复杂度O(log n)通常是指额外的空间复杂度，即不包括输入数据本身所占用的空间。

二叉搜索树代码示例：
```
class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BST {
public:
    TreeNode* root;
    BST() : root(nullptr) {}

    void insert(int val) {
        root = insertNode(root, val);
    }

    TreeNode* insertNode(TreeNode* node, int val) {
        if (node == nullptr) {
            return new TreeNode(val);
        }

        if (val < node->val) {
            node->left = insertNode(node->left, val);
        } else if (val > node->val) {
            node->right = insertNode(node->right, val);
        }

        return node;
    }
};
```
在这个例子中，我们定义了一个二叉搜索树的节点类`TreeNode`，并定义了一个二叉搜索树类`BST`。在这个类中，我们使用指向根节点的指针`root`来描述二叉搜索树。在`BST`类中，我们定义了一个`insert`方法，该方法用于将一个新值插入到二叉搜索树中。我们通过递归地调用`insertNode`方法来插入节点。在这个方法中，我们首先检查当前节点是否为空，如果为空，则为新值创建一个新节点。否则，我们将值与当前节点的值进行比较，并根据比较结果递归地调用`insertNode`方法来将新值插入到左子树或右子树中。

在这个二叉搜索树的实现中，每个节点只需要存储一个整数值和两个指向子节点的指针。因此，每个节点的空间复杂度是O(1)。整个二叉搜索树的空间复杂度取决于树的高度，因为节点数最多为2^h-1个，其中h是树的高度。在一个平衡的二叉搜索树中，树的高度是O(log n)，因此该二叉搜索树的空间复杂度是O(log n)。但是，如果二叉搜索树不平衡，则树的高度可能会达到O(n)，因此空间复杂度也可能是O(n)。